# Лабораторная работа №2 по курсу "Алгоритмы и структуры данных 2"

## Введение
Данная лабораторная работа направлена на решение определенной задачи тремя разными способами. При этом необходимо измерить время каждого алгоритма. Необходимо выяснить, при каком объеме начальных данных и точек какой алгоритм эффективнее.
Если алгоритм включает в себя стадию препроцессинга, то требуется вычислить время как подготовки, так и получения ответа отдельно.

## Условие задачи
Даны прямоугольники на плоскости с двумя углами в целочисленных координатах (левый нижний и правый верхний).
Требуется как можно быстрее выдавать ответ на вопрос: скольким прямоугольникам принадлежит точка (x, y)? Подготовка данных должна занимать мало времени.
> [!NOTE]
> Только нижние границы включены => ```(x1 <= x) && (x < x2) && (y1 <= y) && (y < y2)```, где x и y - координаты точки

## Использование и бенчмаркинг
Проект написан на .Net. Для сборки необходимо запустить dotnet run -c Release (необходимо иметь установленный Dotnet SDK).
Проводилось на следующем оборудовании и ПО:

> BenchmarkDotNet v0.13.12, Windows 11 (10.0.22631.3447/23H2/2023Update/SunValley3)  
> 12th Gen Intel Core i5-12500H, 1 CPU, 16 logical and 12 physical cores  
> .NET SDK 8.0.201  
> [Host]     : .NET 8.0.2 (8.0.224.6711), X64 RyuJIT AVX2  
> DefaultJob : .NET 8.0.2 (8.0.224.6711), X64 RyuJIT AVX2  

## Подробнее про алгоритмы
> [!NOTE]
> Далее ```n``` - количество прямоугольников

### Наивный алгоритм
Не требует препроцессинга и легкий в реализации алгоритм грубой силы. При поиске происходит простой перебор всех прямоугольников для каждой точки, чтобы проверить ее включение в этот прямоугольник.
При фиксированном количестве точек алгоритм работает за ```O(n)```.

|*Итоговые ассимптотики:*|     |
|--------------- | --------------- |
| Подготовка   | *O(1)*   |
| Ответ на запрос   | *O(N)*   |
| По памяти   | *O(N)* на хранение всех прямоугольников  |

### Алгоритм сжатия координат с построением карты
>[!NOTE]
>В следующих двух алгоритмах используются массивы ```xArray``` и ```yArray``` - уникальные значения x и y, отсортированные в порядке возрастания,
>а также словари ```matrixXIndexes``` и ```matrixYIndexes```, которые будут сопоставлять значения x и y с их индексами в массивах ```xArray``` и ```yArray```.

Данный алгоритм более сложный в исполнении и уже требует подготовки определенных данных.
Сначала нужно получить уникальные значения координат прямоугольников, т.е. все значения x и y, использовавшиеся для описания границ прямойгольников,
в отсортированном порядке. Далее для каждого прямоугольника по его координатам определяем уже посчитанные индексы на карте и заполняем ее поля, прибавляя по единице.
> [!IMPORTANT]
> Нельзя увеличивать значение в тех ячейках карты, которые представляют собой верхнюю и правую границы прямоугольника,
> т.е. содержат в себе хотя бы одно значение координаты конца прямоугольника (правый верхний угол), так как по условию задачи такая точка не пренадлежит ему.

Процесс подготовки в этом алгоритме имеет в себе три основных цикла, следовательно, сложность этого процесса равна ```O(n^3)```.

При поиске ответа мы вычисляем для координат точек индексы на карте с помощью бинарного поиска или напрямую через словари, если такие координаты в них есть,
и по ним получаем количество прямоугольников для точки. Время работы составит ```O(log(n))```, так как поиск индексов производится через бинарный поиск.

|*Итоговые ассимптотики:*| |
|-------------|----------|
|Подготовка   |*O(N^3)* |
|Ответ на запрос | *O(log(N))*|
|По памяти | *O(N^2)* в худшем случае|

### Алгоритм на персистентном дереве отрезков
Данный алгоритм является самым сложным в реализации, но самым эффективным. При подготовке данных требуется построить персистентное дерево отрезков.
Для этого использовался дополнительный класс Modification, который несет в себе смысл прямой, сканирующей координатную плоскость с прямоугольниками для определения их количества на каждой координате x.
Все ноды в дереве отвечают за определенный интервал по оси y. Тогда к нодам дерева, чей интервал по оси y yполностью входит в интервал, хранящийся в определенной модификации, прибавляется или вычитается 1
в зависимости от того, встретилось начало или конец прямоугольника. Алгоритм построения дерева занимает ```O(n*log(n))``` времени.

Поиск ответа для точки осуществляется через доступ к определенной версии дерева через координату x, равную координате x самой точки, и поиск нужного интервала в дереве, используя координату y.
Время поиска занимает ```O(log(n))``` времени, как и во втором алгоритме.

|*Итоговые ассимптотики:* |  |
|-------------------------|--|
|Подготовка | *O(N\*log(N))* |
|Ответ на запрос | *O(log(N))* |
|По памяти | *O(N\*log(N))* в худшем случае |

## Сравнение времени работы алгоритмов
> [!NOTE]
> Количество прямоугольников в тестах равняется ```2^i```, где 1 <= i <= 10.
> Количество точек во всех тестах равняется ```1000```.

### Время выдачи ответов для трех алгоритмов

![answer_time_graph](https://github.com/valeriii25/AlgorithmsLab2/assets/130287402/ef69b8db-5318-4997-8a1a-85433ce46f3f)

На маленьких данных лучше себя показывает второй алгоритм с использованием карты, хотя его значения не сильно разнятся с результатами третьего алгоритма на персистентном д.о..
Это объясняется тем, что при поиске карта дважды использует бинарный поиск и потом обращается к ячейке матрицы за ```O(1)```, тогда как в д.о. необходимо пройтись еще по самому дереву,
что увеличивает константу у сложности (однако она не учитывается в асимптотике).
На больших данных их результаты всё так же не значительно разнятся, чего не скажешь о наивном решении. Еще на маленьких входных данных он показывал себя хуже всего, а с увеличением размеров данных
стал значительно проигрывать двум другим алгоритмам в скорости.

### Время препроцессинга карты и персистентного дерева отрезков

![preparation_time_graph](https://github.com/valeriii25/AlgorithmsLab2/assets/130287402/29d4c5e8-1577-4096-ad28-1e2e13b05c35)

На маленьких данных построение карты совсем немного опережает построение персистентного д.о.. Это происходит из-за большого числа структур и выделения памяти при построении дерева.
Но из-за большой разницы в ассимптотике построение карты на больших объемах входных данных начинает занимать значительно больше времени, чем подготовка данных для алгоритма на дереве.

### Итоги
В системе, где некритично время выполнения и небольшие данные, хорошо подходит переборных алгоритм, так как он тратит гораздо меньше памяти, не требует времени на подготовку, быстро и легко пишется.
В системе, где критично время выполнения и небольшие данные, лучше использовать алгоритм на карте. Он быстрее отвечает на запрос, чем алгоритм на дереве,
однако больше использует памяти и дольше подготавливается, что делает его менее пригодным для больших данных.
В системе, где большой объем данных и нужно быстро выполнять запросы, идельным вариантом будет решение на персистентном дереве отрезков.
С учетом всех результатов наиболее эффективным алгоритмом является третий, хоть он и наиболее трудоемок в реализации.
